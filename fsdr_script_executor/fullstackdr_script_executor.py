#!/usr/bin/python3.6.8 -Es
# -*- coding: utf-8 -*-

"""
Copyright (c) 2016, 2023, Oracle and/or its affiliates.
Licensed under the Universal Permissive License (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl/

This is the top-level entry point for the FSDR Script executor.

Script tested on Python 2.7.18 and Python 3.6.8.
"""

__author__ = "Oracle Corp."
__version__ = "1.0"
__copyright__ = (
    """ Copyright (c) 2022, Oracle and/or its affiliates. All rights reserved. """
)

import sys

# FSDR Agent: no cover for windows for now
if sys.platform == "win32":
    print("ERROR: FSDR Agent Script is not supported on Windows")
    sys.exit(1)

# Python 3.6.8 is current Oracle VM supports as of 03/30/202
if sys.version_info < (2,):
    print("ERROR: FSDR Agent Script is supported on and above Python 2.+")
    sys.exit(1)

import argparse
from argparse import RawDescriptionHelpFormatter
import datetime
import logging
import os
import signal
import socket
import subprocess
import threading
import time

# Global declarations
log = None
stopDrcsWorker = False
extractedDownloadDir = None
now = datetime.datetime.now()
python2 = False

# Python 2 and 3:
try:
    # Python 3 APIs
    import urllib.request as urllib2
    import urllib.parse as urlparse
    from urllib.request import urlretrieve
except ImportError:
    # Python 2 APIs
    import urllib
    import urllib2
    import urlparse

    python2 = True


class _SupportedArchives:
    """
    FSDR Supported Archives
    """

    def __init__(self):
        pass

    ARCHIVE_ZIP = ".zip"
    ARCHIVE_TAR_GZ = ".tar.gz"
    ARCHIVE_TAR = ".tar"
    ARCHIVE_TGZ = ".tgz"
    ARCHIVE_GZ = ".gz"
    ARCHIVE_BZIP2 = ".bz2"


class _DrcsConstants:
    """
    FSDR Constants
    """

    def __init__(self):
        pass

    DRCS_DATE_TIME_FORMAT = "_%Y%m%d.%H%M%S.%f"

    DRCS_LOG_DIRECTORY_DEFAULT = "/tmp/drcs_logs"

    DRCS_LOG_DIRECTORY = DRCS_LOG_DIRECTORY_DEFAULT + now.strftime("_%Y%m%d_%H%M%S_%f")
    DRCS_LOG_FILE_NAME = "/fsdr" + now.strftime(DRCS_DATE_TIME_FORMAT) + ".log"

    DRCS_DOWNLOAD_DIR = (
        DRCS_LOG_DIRECTORY + "/download" + now.strftime("_%Y%m%d_%H%M%S_%f")
    )

    SCRIPT_TYPE_LOCAL = "local"
    SCRIPT_TYPE_OSS = "objectstorage"

    PRECHECK_MODE = "precheck"
    EXECUTE_MODE = "execute"

    DRCS_WORKER_TAG = "[fsdr-wrkr]"
    SUCCESS_TAG = "[SUCCESS]"
    FAILED_TAG = "[FAILED]"
    WARNING_TAG = "[WARNING]"
    PRECHECK_TAG = "[PRECHECK]"
    EXECUTE_TAG = "[EXECUTE]"

    DEFAULT_LOG_UPLOAD_INTERVAL = 10

    DRCS_CMD_EXECUTE_CURL_VALIDATE_PAR = "curl --head --silent {}"
    DRCS_CMD_EXECUTE_CURL_UPLOAD_LOGS_TO_OSS = "curl -T {} {}"
    DRCS_CMD_EXECUTE_SUDO_TO_EXECUTE_SCRIPT = "sudo -u {}"
    DRCS_CMD_EXECUTE_SUDO_CHECK = "sudo -i -u {} whoami && date"
    DRCS_CMD_EXECUTE_LS = ["ls", "-lsRt"]
    DRCS_CMD_EXECUTE_RM = ["rm", "-rf"]
    DRCS_CMD_EXECUTE_CLEAR = ["clear"]
    DRCS_CMD_EXECUTE_WHICH = "which"


class _DRCSWorker(object):
    """
    FSDR Worker that starts at the beginning and upload logs generated by this script to customer
    ObjectStore using PAR user-provided as part of oss_log_location. Worker triggers to
    Logfile upload every few seconds with an interval of value of log_upload_interval
    """

    def __init__(self, interval=1, par_url=None, log_file=None):
        self.interval = interval
        self.par_url = par_url
        self.log_file = log_file

        log.info(
            "{} Starting worker to upload logs to OSS".format(
                _DrcsConstants.DRCS_WORKER_TAG
            )
        )
        log.info(
            "{0} LogUploader - interval: [{1}], log_file: [{2}], par_url: [{3}]".format(
                _DrcsConstants.DRCS_WORKER_TAG,
                self.interval,
                self.log_file,
                self.par_url,
            )
        )

    def start(self):
        """
        Starts the worker thread and that invokes run()
        """

        thread = threading.Thread(target=self.run, args=())
        thread.daemon = True
        thread.start()

        log.info("{} FSDR worker started".format(_DrcsConstants.DRCS_WORKER_TAG))

    def run(self):
        """
        Runs the worker thread
        """

        self._upload_logs_to_object_store()

    def _upload_logs_to_object_store(self):
        """
        Upload logs to customer object store
        """

        log.info(
            "{0} Uploading logs to OSS bucket - PAR URL: [{1}], Logfile to be uploaded [{2}]".format(
                _DrcsConstants.DRCS_WORKER_TAG, self.par_url, self.log_file
            )
        )
        time.sleep(2)

        while True:
            log.info(
                "{0} FSDR worker attempt - interval: [{1}]".format(
                    _DrcsConstants.DRCS_WORKER_TAG, self.interval
                )
            )

            self.upload_logs()

            time.sleep(self.interval)

            if stopDrcsWorker:
                log.info(
                    "{} FSDR worker is disabled, so uploading logs to OSS bucket one last time".format(
                        _DrcsConstants.DRCS_WORKER_TAG
                    )
                )
                self.upload_logs()
                log.info(
                    "{} Logfile uploading to OSS bucket is completed".format(
                        _DrcsConstants.DRCS_WORKER_TAG
                    )
                )
                break

        log.info(
            "{} A worker that uploads logs to the OSS bucket is terminated".format(
                _DrcsConstants.DRCS_WORKER_TAG
            )
        )

    def upload_logs(self):
        """
        Upload logs to customer object store
        """

        log.info("{} Uploading logs to OSS".format(_DrcsConstants.DRCS_WORKER_TAG))

        upload_logs_cmd = (
            _DrcsConstants.DRCS_CMD_EXECUTE_CURL_UPLOAD_LOGS_TO_OSS.format(
                self.log_file, self.par_url
            )
        )
        validate_par_cmd = _DrcsConstants.DRCS_CMD_EXECUTE_CURL_VALIDATE_PAR.format(
            self.par_url
        ).split(" ")

        try:
            log.info(
                "{0} Executing command to upload logfile to OSS - [{1}]".format(
                    _DrcsConstants.DRCS_WORKER_TAG, upload_logs_cmd
                )
            )

            log.info(
                "{0} Checking if par_url is accessible - [{1}]".format(
                    _DrcsConstants.DRCS_WORKER_TAG, self.par_url
                )
            )

            parl_url_output = (
                subprocess.check_output(
                    validate_par_cmd,
                    shell=False,
                )
                .decode("utf-8")
                .strip()
            ).split("\n")[0]

            if (
                parl_url_output is not None
                and parl_url_output.strip() == "HTTP/1.1 200 OK"
            ):
                log.info(
                    "{0} par_url is accessible - [{1}]".format(
                        _DrcsConstants.DRCS_WORKER_TAG, parl_url_output.strip()
                    )
                )
                output = (
                    subprocess.check_output(
                        upload_logs_cmd,
                        shell=False,
                    )
                    .decode("utf-8")
                    .strip()
                )

                if output is not None and len(output) > 0:
                    log.info(
                        "{0} Logfile upload to OSS was successful - command output - [{1}]".format(
                            _DrcsConstants.DRCS_WORKER_TAG, output
                        )
                    )
                else:
                    log.info(
                        "{0} Logfile upload to OSS was successful".format(
                            _DrcsConstants.DRCS_WORKER_TAG
                        )
                    )
            else:
                log.info(
                    "{0} par_url is not accessible - [{1}] - ignoring OSS logfile upload. Make sure PAR is valid "
                    "and not expired - [{2}]".format(
                        _DrcsConstants.DRCS_WORKER_TAG,
                        parl_url_output.strip(),
                        self.par_url,
                    )
                )

        except subprocess.CalledProcessError as e:
            log.warn(
                "{0} Logfile upload failed - [{1}], error - [{2}] - Upload will be retried in the next attempt".format(
                    _DrcsConstants.DRCS_WORKER_TAG, upload_logs_cmd, e
                )
            )


class _Mode(object):
    """
    Parent class which will be used from Precheck and Execute Mode use cases
    """

    def __init__(self, script_type=None, args=None):
        self.script_type = script_type
        self.args = args

        self._script_execution_details()
        self._print_environment()
        self.print_arguments()

    @staticmethod
    def _script_execution_details():
        """
        Script execution details for debugging
        """

        log.info("Script execution details......")
        log.info("# of script arguments - #[{}]".format(len(sys.argv)))
        log.info("Script arguments - [{}]".format(sys.argv))

    @staticmethod
    def _print_environment():
        """
        Prints environment details
        """

        log.info("Environment details......")
        log.info("hostname - [{}]".format(socket.gethostname()))
        log.info("python version_info - [{}]".format(sys.version_info))

        # Seeing error on below line "OSError: [Errno 6] No such device or address"
        # This is only happening when running this script via OCA agent
        # log.info("whoami - [{}]".format(os.getlogin()))

        log.info("uid - [{}]".format(os.getuid()))
        log.info("gid - [{}]".format(os.getgid()))
        log.info(
            "current directory - [{}]".format(
                os.path.dirname(os.path.abspath(__file__))
            )
        )

    def print_arguments(self):
        """
        Prints user inputs
        """

        log.info("User inputs......")
        log.info("run_as_user - [{}]".format(self.args.run_as_user))
        log.info("mode - [{}]".format(self.args.mode))
        log.info("script_type - [{}]".format(self.args.script_type))
        log.info("script_interpreter - [{}]".format(self.args.script_interpreter))
        log.info("script_path - [{}]".format(self.args.script_path))
        log.info("script_arguments - [{}]".format(self.args.script_arguments))
        log.info("oss_log_location - [{}]".format(self.args.oss_log_location))

    def run_common_precheck(self):
        """
        Run common prechecks for precheck and execute modes
        """

        _is_precheck_failed = False

        log.info(
            "{0} Execution mode [{1}] - script_type [{2}]...".format(
                _DrcsConstants.PRECHECK_TAG, self.args.mode, self.args.script_type
            )
        )

        if (
            self.args.script_interpreter is not None
            and len(self.args.script_interpreter) > 0
        ):
            which_cmd = _DrcsConstants.DRCS_CMD_EXECUTE_WHICH.format(
                str(self.args.script_interpreter)
            )

            log.info(
                "{0} Which command [{1}]".format(_DrcsConstants.PRECHECK_TAG, which_cmd)
            )

            status = subprocess.call(
                [_DrcsConstants.DRCS_CMD_EXECUTE_WHICH, self.args.script_interpreter]
            )

        if status != 0:
            log.error(
                "{0} script_interpreter provided not valid. User Input - [{1}] - {2}".format(
                    _DrcsConstants.PRECHECK_TAG,
                    self.args.script_interpreter,
                    _DrcsConstants.FAILED_TAG,
                )
            )
            _is_precheck_failed = True
        else:
            log.info(
                "{0} script_interpreter provided is valid. User Input - [{1}] - {2}".format(
                    _DrcsConstants.PRECHECK_TAG,
                    self.args.script_interpreter,
                    _DrcsConstants.SUCCESS_TAG,
                )
            )

        if self.args.run_as_user is not None and len(self.args.run_as_user) > 0:
            try:
                output = (
                    subprocess.check_output(
                        _DrcsConstants.DRCS_CMD_EXECUTE_SUDO_CHECK.format(
                            str(self.args.run_as_user)
                        ),
                        shell=False,
                    )
                    .decode("utf-8")
                    .strip()
                )
                log.info(
                    "{0} run_as_user SUDO check for user [{1}] was successful - {2}".format(
                        _DrcsConstants.PRECHECK_TAG,
                        self.args.run_as_user,
                        _DrcsConstants.SUCCESS_TAG,
                    )
                )

                if output is not None and len(output) > 0:
                    log.info(
                        "{0} run_as_user SUDO check output for user [{1}] - [{2}] - {3}".format(
                            _DrcsConstants.PRECHECK_TAG,
                            self.args.run_as_user,
                            output,
                            _DrcsConstants.SUCCESS_TAG,
                        )
                    )

            except subprocess.CalledProcessError as e:
                log.error(
                    "{0} run_as_user SUDO check for user [{1}] was failed - [{2}] - {3}".format(
                        _DrcsConstants.PRECHECK_TAG,
                        self.args.run_as_user,
                        e,
                        _DrcsConstants.FAILED_TAG,
                    )
                )
                _is_precheck_failed = True

        if (
            self.args.oss_log_location is not None
            and len(self.args.oss_log_location) > 0
        ):
            try:
                validate_par_cmd = (
                    _DrcsConstants.DRCS_CMD_EXECUTE_CURL_VALIDATE_PAR.format(
                        self.args.oss_log_location
                    )
                ).split(" ")

                output = (
                    subprocess.check_output(
                        validate_par_cmd,
                        shell=False,
                    )
                    .decode("utf-8")
                    .strip()
                ).split("\n")[0]

                if output is not None and output.strip() == "HTTP/1.1 200 OK":
                    log.info(
                        "{0} oss_log_location is valid. Output - [{1}] User Input - [{2}] - {3}".format(
                            _DrcsConstants.PRECHECK_TAG,
                            output,
                            self.args.oss_log_location,
                            _DrcsConstants.SUCCESS_TAG,
                        )
                    )
                else:
                    log.error(
                        "{0} oss_log_location is invalid, make sure PAR is valid and not expired. Output - [{1}] User Input - [{2}] - {3}".format(
                            _DrcsConstants.PRECHECK_TAG,
                            output,
                            self.args.oss_log_location,
                            _DrcsConstants.FAILED_TAG,
                        )
                    )
                    _is_precheck_failed = True

            except subprocess.CalledProcessError as e:
                log.error(
                    "{0} oss_log_location is invalid. Error - [{1}] - User Input - [{2}] - {3}".format(
                        _DrcsConstants.PRECHECK_TAG,
                        e,
                        self.args.oss_log_location,
                        _DrcsConstants.FAILED_TAG,
                    )
                )
                _is_precheck_failed = True

        return _is_precheck_failed


class _Precheck:
    """
    Handles all the prechecks for Local and ObjectStore script types
    """

    def __init__(self, script_type=None, args=None):
        self.script_type = script_type
        self.args = args

    def _precheck_local_scripts(self):
        """
        Performs the precheck for Local script type
        """

        _is_oss_precheck_failed = _Mode(
            self.script_type, self.args
        ).run_common_precheck()

        # Below prechecks are only applicable to Local script type
        if self.args.script_path is not None and len(self.args.script_path) > 0:
            is_script_path_exist = os.path.exists(self.args.script_path)
            if not is_script_path_exist:
                log.error(
                    "{0} script_path provided doesn't exist on vm [{1}]. - User Input - [{2}] - {3}".format(
                        _DrcsConstants.PRECHECK_TAG,
                        socket.gethostname(),
                        self.args.script_path,
                        _DrcsConstants.FAILED_TAG,
                    )
                )
                _is_oss_precheck_failed = True
            else:
                log.info(
                    "{0} script_path provided exist. - User Input - [{1}] - {2}".format(
                        _DrcsConstants.PRECHECK_TAG,
                        self.args.script_path,
                        _DrcsConstants.SUCCESS_TAG,
                    )
                )

        return _is_oss_precheck_failed

    def _precheck_oss_script(self):
        """
        Performs the precheck for ObjectStore script type
        """

        _is_oss_precheck_failed = _Mode(
            self.script_type, self.args
        ).run_common_precheck()

        # Below prechecks are only applicable to ObjectStore script type
        if self.args.oss_location is not None and len(self.args.oss_location) > 0:
            try:
                validate_par_cmd = (
                    _DrcsConstants.DRCS_CMD_EXECUTE_CURL_VALIDATE_PAR.format(
                        self.args.oss_location
                    )
                ).split(" ")

                output = (
                    subprocess.check_output(
                        validate_par_cmd,
                        shell=False,
                    )
                    .decode("utf-8")
                    .strip()
                ).split("\n")[0]

                if output is not None and output.strip() == "HTTP/1.1 200 OK":
                    log.info(
                        "{0} oss_location is valid. Output - [{1}] User Input - [{2}] - {3}".format(
                            _DrcsConstants.PRECHECK_TAG,
                            output,
                            self.args.oss_location,
                            _DrcsConstants.SUCCESS_TAG,
                        )
                    )
                else:
                    log.error(
                        "{0} oss_location is invalid, make sure PAR is valid and not expired. Output - [{1}] User Input - [{2}] - {3}".format(
                            _DrcsConstants.PRECHECK_TAG,
                            output,
                            self.args.oss_location,
                            _DrcsConstants.FAILED_TAG,
                        )
                    )
                    _is_oss_precheck_failed = True

            except subprocess.CalledProcessError as e:
                log.error(
                    "{0} oss_location is invalid. Error - [{1}] - User Input - [{2}] - {3}".format(
                        _DrcsConstants.PRECHECK_TAG,
                        e,
                        self.args.oss_location,
                        _DrcsConstants.FAILED_TAG,
                    )
                )
                _is_oss_precheck_failed = True

        if (
            _is_oss_precheck_failed is False
            and self.args.script_path is not None
            and len(self.args.script_path) > 0
        ):
            log.info(
                "{0} Checking if oss_location (PAR) [{1}] has script_path [{2}]".format(
                    _DrcsConstants.PRECHECK_TAG,
                    self.args.oss_location,
                    self.args.script_path,
                )
            )
            objectStoreAdaptor = _ObjectStoreAdaptor(self.args.oss_location)

            path, target_dir = objectStoreAdaptor.download_and_extract()

            log.info(
                "{0} path - [{1}], target_dir - [{2}], script_path - [{3}]".format(
                    _DrcsConstants.PRECHECK_TAG, path, target_dir, self.args.script_path
                )
            )

            is_script_path_exist = os.path.exists(
                target_dir + "/" + self.args.script_path
            )

            log.info(
                "{0} script_path [{1}] exists? - [{2}]".format(
                    _DrcsConstants.PRECHECK_TAG,
                    target_dir + "/" + self.args.script_path,
                    is_script_path_exist,
                )
            )

            if not is_script_path_exist:
                log.error(
                    "{0} user script_path doesn't exist on vm [{1}] after downloading from oss_location [{2}] - User "
                    "Input - [{3}] - {4}".format(
                        _DrcsConstants.PRECHECK_TAG,
                        socket.gethostname(),
                        self.args.oss_location,
                        self.args.script_path,
                        _DrcsConstants.FAILED_TAG,
                    )
                )
                _is_oss_precheck_failed = True
            else:
                log.info(
                    "{0} script_path provided exist. - User Input - [{1}] - {2}".format(
                        _DrcsConstants.PRECHECK_TAG,
                        self.args.script_path,
                        _DrcsConstants.SUCCESS_TAG,
                    )
                )

        # Cleanup working directory if the mode is Prechecks
        # For Execution mode, we do this cleanup towards the end
        if self.args.mode == _DrcsConstants.PRECHECK_MODE:
            is_target_directory_exist = os.path.exists(target_dir)

            log.info(
                "{0} Working directory [{1}] exists? - [{2}]".format(
                    _DrcsConstants.PRECHECK_TAG, target_dir, is_target_directory_exist
                )
            )

            if is_target_directory_exist:
                log.info(
                    "{0} Cleaning up working directory [{1}] for mode [{1}]".format(
                        _DrcsConstants.PRECHECK_TAG, target_dir, self.args.mode
                    )
                )
                objectStoreAdaptor.cleanup_working_directory(target_dir)

        return _is_oss_precheck_failed

    def run(self):
        """
        Run the precheck for the given script type, which can be Local or ObjectStore
        """

        is_precheck_failed = False

        if self.script_type == _DrcsConstants.SCRIPT_TYPE_LOCAL:
            is_precheck_failed = self._precheck_local_scripts()
        elif self.script_type == _DrcsConstants.SCRIPT_TYPE_OSS:
            is_precheck_failed = self._precheck_oss_script()

        if is_precheck_failed:
            log.error(
                "{0} At least one precheck is failed. Check the above logs for more details. {1}".format(
                    _DrcsConstants.PRECHECK_TAG, _DrcsConstants.FAILED_TAG
                )
            )
        else:
            log.info(
                "{0} All prechecks were successful. {1}".format(
                    _DrcsConstants.PRECHECK_TAG, _DrcsConstants.SUCCESS_TAG
                )
            )

        return is_precheck_failed


class _Execute(_Mode):
    """
    Handles all the execute use case for Local and ObjectStore script types
    """

    def __init__(self, script_type=None, args=None):
        self.script_type = script_type
        self.args = args

    def execute(self):
        """
        Handles all the execute use case for Local and ObjectStore script types, invokes _RunCommand API to execute
        the script or command
        """

        log.info(
            "{0} Execution mode [{1}] - script_type [{2}]...".format(
                _DrcsConstants.EXECUTE_TAG, self.args.mode, self.args.script_type
            )
        )

        if self.args.script_type == _DrcsConstants.SCRIPT_TYPE_LOCAL:
            log.info("Executing Local script - [{}]".format(self.args.script_path))

            out, err, status = _ExecuteCommand(
                self.args.script_interpreter,
                self.args.script_path,
                self.args.script_arguments,
                self.args.run_as_user,
            ).run()
        else:
            log.info("oss_location - [{}]".format(self.args.oss_location))
            log.info("Executing OSS script - [{}]".format(self.args.oss_location))

            objectStoreAdaptor = _ObjectStoreAdaptor(self.args.oss_location)

            path, target_dir = objectStoreAdaptor.download_and_extract()

            out, err, status = _ExecuteCommand(
                self.args.script_interpreter,
                target_dir + "/" + self.args.script_path,
                self.args.script_arguments,
                self.args.run_as_user,
            ).run()

            log.info(
                "Cleanup location - [{}]".format(
                    target_dir + "/" + self.args.script_path
                )
            )

            objectStoreAdaptor.cleanup_working_directory(target_dir)

        return status


class _ObjectStoreAdaptor(object):
    """
    The API that handles the interaction with ObjectStore to download, extract the scripts
    """

    def __init__(self, par_url=None):
        self.par_url = par_url

    @staticmethod
    def _kb_to_mb(kb):
        """
        Converts KB to MB
        """

        return kb / 1024.0 / 1024.0

    @staticmethod
    def _find_archive_extension(filename):
        """
        Find the archive extension for a given filename with an extension
        """

        if filename.endswith(_SupportedArchives.ARCHIVE_ZIP):
            return _SupportedArchives.ARCHIVE_ZIP
        elif filename.endswith(_SupportedArchives.ARCHIVE_TAR_GZ):
            return _SupportedArchives.ARCHIVE_TAR_GZ
        elif filename.endswith(_SupportedArchives.ARCHIVE_TAR):
            return _SupportedArchives.ARCHIVE_TAR
        elif filename.endswith(_SupportedArchives.ARCHIVE_TGZ):
            return _SupportedArchives.ARCHIVE_TGZ
        elif filename.endswith(_SupportedArchives.ARCHIVE_GZ):
            return _SupportedArchives.ARCHIVE_GZ
        elif filename.endswith(_SupportedArchives.ARCHIVE_BZIP2):
            return _SupportedArchives.ARCHIVE_BZIP2

    def _get_size(self):
        """
        Return the size of content received
        """

        meta = urllib2.urlopen(self.par_url).info()
        meta_func = meta.getheaders if hasattr(meta, "getheaders") else meta.get_all
        meta_length = meta_func("Content-Length")

        try:
            return int(meta_length[0])
        except:
            return 0

    def _download(self):
        """
        Downloads to ObjectStore object using given PAR location
        """

        log.info("Downloading OSS object using PAR URL - [{0}]".format(self.par_url))

        oss_object_name = os.path.basename(urlparse.urlparse(self.par_url).path)

        log.info("OSS object to be downloaded - [{0}]".format(oss_object_name))

        try:
            target_dir = _DrcsConstants.DRCS_DOWNLOAD_DIR

            log.info(
                "OSS object will be downloaded at the target directory - [{}]".format(
                    _DrcsConstants.DRCS_DOWNLOAD_DIR
                )
            )

            is_target_dir_exist = os.path.exists(_DrcsConstants.DRCS_DOWNLOAD_DIR)

            log.info(
                "Does the target directory exist? - [{}]".format(is_target_dir_exist)
            )

            if not is_target_dir_exist:
                os.makedirs(_DrcsConstants.DRCS_DOWNLOAD_DIR)
                log.info(
                    "The new target directory [{}] created".format(
                        _DrcsConstants.DRCS_DOWNLOAD_DIR
                    )
                )
                os.chdir(os.path.dirname(_DrcsConstants.DRCS_DOWNLOAD_DIR))

            try:
                log.info(
                    "Downloading OSS object [{0}] - [{1}] ({2:3.1f} MB)".format(
                        oss_object_name, self.par_url, self._kb_to_mb(self._get_size())
                    )
                )

                path = os.path.join(_DrcsConstants.DRCS_DOWNLOAD_DIR, oss_object_name)

                if python2:
                    filename, headers = urllib.urlretrieve(self.par_url, path)
                else:
                    filename, headers = urlretrieve(self.par_url, path)

                log.info(
                    "The OSS object download completed successfully [{0}] using [{1}] APIs".format(
                        filename, "Python 2" if python2 else "Python 3"
                    )
                )
                log.info("The OSS object Headers: [{0}]".format(headers))
            except Exception as e:
                log.error(
                    "Error occurred - Couldn't download [{}] - [{}]".format(
                        self.par_url, e
                    )
                )
                return

        finally:
            os.chdir(os.getcwd())

        log.info(
            "The OSS object [{0}] downloaded at location [{1}]".format(
                path, _DrcsConstants.DRCS_DOWNLOAD_DIR
            )
        )

        return filename, target_dir

    def _extract(self, path, file_name, target_dir):
        """
        Extracts the zip/tarball if it is not a script. It is script it will only download the same
        """

        log.info(
            "Extracting archive [{0}] in directory [{1}], path [{2}]".format(
                file_name, target_dir, path
            )
        )

        if file_name.endswith(_SupportedArchives.ARCHIVE_ZIP):
            log.info(
                "Extracting [{0}] archive, filename [{1}]".format(
                    _SupportedArchives.ARCHIVE_ZIP, file_name
                )
            )

            import shutil, zipfile

            with zipfile.ZipFile(file_name) as zipFile:
                top_dirs = []
                for file_names in zipFile.namelist():
                    if file_names.endswith("/"):
                        if len(file_names.split("/")) == 2:
                            top_dirs.append(file_names.split("/")[0])
                        continue
                    directory = "/".join(file_names.split("/")[0:-2])
                    if directory.find("/") == -1:
                        top_dirs.append(directory)
                    if (
                        len(directory) > 0
                        and not directory.startswith("/")
                        and (directory.find("..") == -1)
                        and not os.path.exists(directory)
                    ):
                        os.makedirs(directory)
                    zipFile.extract(file_names)

                top_dirs = filter(lambda x: len(x) != 0, top_dirs)
                top_dirs = list(set(top_dirs))

                if not top_dirs:
                    top_dirs = [zipFile.namelist()[0]]
                    # target_dir = target_dir + "/" + top_dirs[0]
                if len(top_dirs) > 1:
                    os.makedirs(target_dir)
                    for d in top_dirs:
                        shutil.move(d, "%s/%s" % (target_dir, d))
                else:
                    shutil.move(top_dirs[0], target_dir)
                    # target_dir = target_dir + "/" + top_dirs[0]

                    return path, target_dir
        elif (
            file_name.endswith(_SupportedArchives.ARCHIVE_BZIP2)
            or file_name.endswith(_SupportedArchives.ARCHIVE_TAR)
            or file_name.endswith(_SupportedArchives.ARCHIVE_TAR_GZ)
            or file_name.endswith(_SupportedArchives.ARCHIVE_TGZ)
            or file_name.endswith(_SupportedArchives.ARCHIVE_GZ)
        ):

            log.info(
                "Extracting [{0}] archive, filename [{1}]".format(
                    self._find_archive_extension(file_name), file_name
                )
            )

            import tarfile, shutil

            with tarfile.open(file_name) as tar:
                tar.extractall(target_dir)
                extractedDirectory = tar.getnames()[0]
                extractedDirectoryFullPath = target_dir + "/" + extractedDirectory

                log.info(
                    "The extracted directory - [{0}]".format(extractedDirectoryFullPath)
                )
                log.info(
                    "A list of all files in target directory BEFORE moving [{0}]".format(
                        os.listdir(target_dir)
                    )
                )

                if os.path.isdir(extractedDirectoryFullPath):
                    log.info(
                        "The [{0}] is directory".format(extractedDirectoryFullPath)
                    )

                    allfiles = os.listdir(extractedDirectoryFullPath)

                    log.info(
                        "A list of all files [{0}] in [{1}]".format(
                            allfiles, extractedDirectoryFullPath
                        )
                    )

                    for fileTobeMoved in allfiles:
                        source = extractedDirectoryFullPath + "/" + fileTobeMoved
                        destination = target_dir
                        log.info(
                            "The source file [{0}] is moving to destination [{1}]".format(
                                source, destination
                            )
                        )
                        shutil.move(source, destination)

                log.info(
                    "A list of all files in target directory [{0}]".format(
                        os.listdir(target_dir)
                    )
                )
                log.info(
                    "TAR extracted at target directory [{0}], path - [{1}]".format(
                        target_dir, path
                    )
                )

                # target_dir = target_dir + "/" + top_dir

                return path, target_dir
        else:
            log.info("Archive [{0}] not supported - [{1}]".format(file_name, path))

            return path, target_dir

    @staticmethod
    def _list(directory):
        """
        List the content of a given directory
        """

        log.info("Content of object downloaded from the OSS - [{}]".format(directory))
        prc = subprocess.Popen(
            _DrcsConstants.DRCS_CMD_EXECUTE_LS, cwd=directory, shell=False
        )
        prc.communicate()

    @staticmethod
    def cleanup_working_directory(directory):
        """
        Cleanup given working directory
        """

        log.info(
            "Cleaning up a current directory - [{}]".format(os.path.dirname(directory))
        )
        log.info(
            "Content of object downloaded from the OSS before cleanup - [{}]".format(
                directory
            )
        )

        directory = _DrcsConstants.DRCS_DOWNLOAD_DIR
        is_target_dir_exist = os.path.exists(directory)

        log.info(
            "Is target working directory exists? - [{}]".format(is_target_dir_exist)
        )

        if is_target_dir_exist:
            log.info("Download directory to be cleaned up [{}]".format(directory))

            prc = subprocess.Popen(
                _DrcsConstants.DRCS_CMD_EXECUTE_LS, cwd=directory, shell=False
            )
            prc.communicate()

            log.info(
                "The OSS object content to be deleted from location - [{}]".format(
                    directory
                )
            )
            log.info(
                "Deleting target working directory - [{}]".format(is_target_dir_exist)
            )

            prc = subprocess.Popen(
                _DrcsConstants.DRCS_CMD_EXECUTE_RM, cwd=str(directory), shell=False
            )
            prc.communicate()

            log.info("Target working directory [{}] is deleted".format(directory))
            is_target_dir_exist = os.path.exists(directory)
            log.info(
                "Is the target working directory exists after delete? - [{}]".format(
                    is_target_dir_exist
                )
            )

    def download_and_extract(self):
        """
        Downloads to ObjectStore object using given PAR location. Extracts the zip/tarball if it is not a script.
        It is script it will only download the same
        """

        global extractedDownloadDir

        if os.path.exists(_DrcsConstants.DRCS_DOWNLOAD_DIR) and not os.path.isfile(
            _DrcsConstants.DRCS_DOWNLOAD_DIR
        ):
            if os.listdir(_DrcsConstants.DRCS_DOWNLOAD_DIR):
                log.info(
                    "Download directory [{}] already exist and not empty".format(
                        _DrcsConstants.DRCS_DOWNLOAD_DIR
                    )
                )
                log.info(
                    "Content of object downloaded from the OSS - [{}]".format(
                        _DrcsConstants.DRCS_DOWNLOAD_DIR
                    )
                )

                prc = subprocess.Popen(
                    _DrcsConstants.DRCS_CMD_EXECUTE_LS,
                    cwd=_DrcsConstants.DRCS_DOWNLOAD_DIR,
                    shell=False,
                )
                prc.communicate()

                log.info(
                    "Directory [{0}] already exist and will be reused as part of precheck".format(
                        _DrcsConstants.DRCS_DOWNLOAD_DIR
                    )
                )

                return None, extractedDownloadDir

        log.info(
            "Download directory [{}] not found so performing download and extract".format(
                _DrcsConstants.DRCS_DOWNLOAD_DIR
            )
        )

        path, target_dir = self._download()

        path, target_dir = self._extract(self.par_url, path, target_dir)

        extractedDownloadDir = target_dir

        self._list(extractedDownloadDir)

        log.info(
            "Extracted the OSS object using PAR URL [{0}] at location [{1}], path [{2}]".format(
                self.par_url, extractedDownloadDir, path
            )
        )

        return path, extractedDownloadDir


class _ExecuteCommand(object):
    """
    Execute the given command or a script
    """

    def __init__(self, interpreter, command, args, run_as_user):
        self.interpreter = interpreter
        self.command = command
        self.args = args
        self.run_as_user = run_as_user

    def _execute_command(self):
        """
        Execute command

        command - can be an array
        run_as_user - can be optional
        """

        cmd = ""

        if self.run_as_user is not None and len(self.run_as_user) > 0:
            cmd = (
                _DrcsConstants.DRCS_CMD_EXECUTE_SUDO_TO_EXECUTE_SCRIPT.format(
                    self.run_as_user
                )
                + " "
            )

        if self.interpreter is not None and len(self.interpreter) > 0:
            cmd = cmd + self.interpreter

        if self.command is not None and len(self.command) > 0:
            cmd = cmd + " " + self.command

        if self.args is not None and len(self.args) > 0:
            cmd = cmd + " " + self.args

        log.info("Dispatching the command - script to be executed - [{}]".format(cmd))

        process = subprocess.Popen(
            cmd.split(" "),
            shell=False,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
        )

        log.info("{:-^100}".format(" script execution output [Start] "))

        while True:
            line = process.stdout.readline()
            if not line:
                break
            log.info(line.rstrip())

        log.info("{:-^100}".format(" script execution output [End] "))

        output = process.communicate()[0]
        err = process.stderr
        status = process.returncode

        if output is not None and len(output) > 0:
            output = output.decode("utf-8")
        if err is not None and len(err) > 0:
            err = err.decode("utf-8")

        return output, err, status

    def run(self):
        """
        API that runs the given command or a script
        """
        log.info("Dispatching script to execute - [{}]".format(self.command))

        out, err, status = self._execute_command()

        if status > 0:
            log.error("ERROR: script execution exit status - [{}]".format(status))
        else:
            log.info("script execution exit status - [{}]".format(status))

        if status > 0:
            log.error("script execution was failed")

            if err is not None and len(err) > 0:
                log.error("{:-^100}".format(" script execution error [Start] "))
                log.error("\n{}".format(err))
                log.error("{:-^100}".format(" script execution error [End] "))
        else:
            log.info("script execution was successful")

        return out, err, status


class _Logger(object):
    """
    Loggers have the following attributes and methods. Note that Loggers should NEVER be instantiated directly,
    but always through the module-level function logging.getLogger(name). Multiple calls to getLogger()
    with the same name will always return a reference to the same Logger object.

    The logger provides API:

    info()
    debug()
    warning()
    error()
    """

    _logger = None
    _dirname = None
    _log_file = None

    def __init__(self):
        self._logger = logging.getLogger(__name__)
        self._logger.setLevel(logging.DEBUG)

        self._add_handlers()

    def _add_handlers(self):
        formatter = logging.Formatter("%(asctime)s:[%(levelname)s]: %(message)s")
        self._dirname = _DrcsConstants.DRCS_LOG_DIRECTORY
        if not os.path.isdir(self._dirname):
            os.mkdir(self._dirname)

        self._log_file = self._dirname + _DrcsConstants.DRCS_LOG_FILE_NAME
        fileHandler = logging.FileHandler(self._log_file)

        streamHandler = logging.StreamHandler()
        fileHandler.setFormatter(formatter)
        streamHandler.setFormatter(formatter)

        self._logger.addHandler(fileHandler)
        self._logger.addHandler(streamHandler)

        print(
            "{0}:[INFO]: Created DRCSScriptExecutor logfile - [{1}]".format(
                now.strftime("%Y-%m-%d %H:%M:%S,%j"), self._log_file
            )
        )

    def getLogger(self):
        return self._logger

    def getLogFile(self):
        return self._log_file


class _CleanUpOnProcessTerminate:
    """
    Protect a piece of code from being killed by SIGINT or SIGTERM.
    It can still be killed by a force kill.

    Example:
        _CleanUpOnProcessTerminate().signal_handler

    Both functions will be executed even if a sigterm or sigkill has been received.

    This API is being used to perform cleanup and receiving force kill signal
    """

    killed = False

    def __init__(self):
        log.info("Signal handler initialized")

    def signal_handler(self, signint, sigterm):
        log.error(
            "Script execution interrupted - Received SIGINT or SIGTERM! Finishing cleanup then exiting"
        )
        self.killed = True

        self._cleanup()

        sys.exit(1)

    # TODO - Cleanup code goes here
    @staticmethod
    def _cleanup():
        log.info("Cleanup initiated")

        _ObjectStoreAdaptor().cleanup_working_directory(
            _DrcsConstants.DRCS_DOWNLOAD_DIR
        )
        log.info("Cleanup is done")

    def __enter__(self):
        self.old_sigint = signal.signal(signal.SIGINT, self._signal_handler)
        self.old_sigterm = signal.signal(signal.SIGTERM, self._signal_handler)

    def __exit__(self, type, value, traceback):
        if self.killed:
            sys.exit(1)
        signal.signal(signal.SIGINT, self.old_sigint)
        signal.signal(signal.SIGTERM, self.old_sigterm)


def argumentParser():
    """
    Argument Parser
    """

    parser = argparse.ArgumentParser(
        prog="fullstackdr_script_executor.py",
        formatter_class=RawDescriptionHelpFormatter,
        description="OCI Full Stack Disaster Recovery (FSDR) Script Executor.\n\n"
        "This script executor is used to execute a user-provided script as a step in a FSDR plan.\n"
        "The user-provided script can either be a local script on an instance or stored as an object in "
        "Object Storage.\n\n",
        epilog="To get additional help for each script type enter: \n\n"
        "\t%(prog)s local --help\n\t%(prog)s objectstorage --help",
    )
    parser.add_argument("--version", action="version", version="%(prog)s 1.0")
    subparsers = parser.add_subparsers(
        title="Script Types",
        metavar="Supported Script Types:",
        dest="script_type",
        description="Types of scripts supported by this script executor.",
    )

    # Git like options - Hence we are adding two subparsers for Local, ObjectStore to handle their arguments seamlessly
    local_parser = subparsers.add_parser(
        _DrcsConstants.SCRIPT_TYPE_LOCAL,
        formatter_class=RawDescriptionHelpFormatter,
        help="A script that is present on the instance",
        description="The user-provided script that is a local script on an instance\n\n",
        epilog="Examples: \n\n"
        "\t1) Execute the local script '/home/user/hello_world.sh' on an instance using the '/bin/sh' interpreter"
        " and pass the argument string '-arg1 val1 -arg2 val2' to the script\n\n"
        "\t  %(prog)s local --mode execute --script_interpreter '/bin/sh' --script_path '/home/user/hello_world.sh'"
        " --script_arguments '-arg1 val1 -arg2 val2'\n\n"
        "\t2) Execute the local script '/home/user/hello_world.sh' on an instance as a user 'oracle' using the "
        "'/bin/sh' interpreter and pass the argument string '-arg1 val1 -arg2 val2' to the script\n\n"
        "\t  %(prog)s local --mode execute --run_as_user oracle --script_interpreter '/bin/sh' --script_path "
        "'/home/user/hello_world.sh' --script_arguments '-arg1 val1 -arg2 val2'\n\n"
        "\t3) Precheck the local script '/home/user/hello_world.sh' on an instance using the '/bin/sh' interpreter "
        "and pass the argument string '-arg1 val1 -arg2 val2' to the script\n\n"
        "\t  %(prog)s local --mode precheck --script_interpreter '/bin/sh' --script_path '/home/user/hello_world.sh' "
        "--script_arguments '-arg1 val1 -arg2 val2'\n\n"
        "\t4) Precheck the local script '/home/user/hello_world.sh' on an instance as a user 'oracle' using the "
        "'/bin/sh' interpreter and pass the argument string '-arg1 val1 -arg2 val2' to the script\n\n"
        "\t  %(prog)s local --mode precheck --run_as_user oracle --script_interpreter '/bin/sh' --script_path "
        "'/home/user/hello_world.sh' --script_arguments '-arg1 val1 -arg2 val2'\n",
    )
    oss_parser = subparsers.add_parser(
        _DrcsConstants.SCRIPT_TYPE_OSS,
        formatter_class=RawDescriptionHelpFormatter,
        help="A script that is stored in Object Storage",
        description="The user-provided script that is stored as an object in Object Storage\n\n",
        epilog="Examples: \n\n"
        "The script shown in the examples below using the ‘--script_path’ argument, is contained in a compressed "
        "archive stored in Object Storage and specified using the --oss_location argument\n\n "
        "\t1) Execute the Object Storage script 'hello_world.sh' on an instance using the '/bin/sh' interpreter and "
        "pass the argument string '-arg1 val1 -arg2 val2' to the script \n\n"
        "\t  %(prog)s local --mode execute --script_interpreter '/bin/sh' --script_path 'hello_world.sh' "
        "--script_arguments '-arg1 val1 -arg2 val2' --oss_location "
        "'https://objectstorage.us-ashburn-1.oraclecloud.com/n/namespace/b/bucket/o/hello_world_object.tar'\n\n"
        "\t2) Execute the Object Storage script 'hello_world.sh' on an instance as a user 'oracle' using the "
        "'/bin/sh' interpreter and pass the argument string '-arg1 val1 -arg2 val2' to the script\n\n"
        "\t  %(prog)s local --mode execute --run_as_user oracle --script_interpreter '/bin/sh' --script_path "
        "'hello_world.sh' --script_arguments '-arg1 val1 -arg2 val2' --oss_location "
        "'https://objectstorage.us-ashburn-1.oraclecloud.com/n/namespace/b/bucket/o/hello_world_object.tar'\n\n"
        "\t3) Precheck the Object Storage script 'hello_world.sh' on an instance using the '/bin/sh' interpreter "
        "and pass the argument string '-arg1 val1 -arg2 val2' to the script\n\n"
        "\t  %(prog)s local --mode precheck --script_interpreter '/bin/sh' --script_path 'hello_world.sh' "
        "--script_arguments '-arg1 val1 -arg2 val2' --oss_location "
        "'https://objectstorage.us-ashburn-1.oraclecloud.com/p/u9yXYXTK-GHJMPR26LJQ5gNYqwbHZIiQpedsIW0UuhpXiAEzQSMqFqVxy2t9FhZt/n/namespace/b/bucket/o/hello_world_object.tar'\n\n"
        "\t4) Precheck the Object Storage script 'hello_world.sh' on an instance as a user 'oracle' using the "
        "'/bin/sh' interpreter and pass the argument string '-arg1 val1 -arg2 val2' to the script\n\n"
        "\t  %(prog)s local --mode precheck --run_as_user oracle --script_interpreter '/bin/sh' --script_path "
        "'hello_world.sh' --script_arguments '-arg1 val1 -arg2 val2' --oss_location "
        "'https://objectstorage.us-ashburn-1.oraclecloud.com/p/u9yXYXTK-GHJMPR26LJQ5gNYqwbHZIiQpedsIW0UuhpXiAEzQSMqFqVxy2t9FhZt/n/namespace/b/bucket/o/hello_world_object.tar'\n",
    )

    # Local
    local_parser.add_argument(
        "--script_interpreter",
        required=False,
        type=str,
        help="The interpreter used to execute the script",
    )
    local_parser.add_argument(
        "--script_path", required=True, type=str, help="The full path of the script"
    )
    local_parser.add_argument(
        "--script_arguments",
        required=False,
        type=str,
        help="The list of arguments to pass to the script",
    )
    local_parser.add_argument(
        "--mode",
        choices=[_DrcsConstants.PRECHECK_MODE, _DrcsConstants.EXECUTE_MODE],
        required=True,
        type=str,
        help="The script executor's mode",
    )
    local_parser.add_argument(
        "--run_as_user",
        required=False,
        type=str,
        help="The user ID to use for executing the script. If not provided, the default OCA user ID (orarun) will be used",
    )
    local_parser.add_argument(
        "--oss_log_location",
        required=False,
        type=str,
        # help="This option is not currently supported"
        help=argparse.SUPPRESS,
    )
    local_parser.add_argument(
        "--log_upload_interval",
        required=False,
        type=int,
        default=_DrcsConstants.DEFAULT_LOG_UPLOAD_INTERVAL,
        # help="This option is not currently supported"
        help=argparse.SUPPRESS,
    )

    # ObjectStore
    oss_parser.add_argument(
        "--script_interpreter",
        required=True,
        type=str,
        help="The interpreter used to execute the script",
    )
    oss_parser.add_argument(
        "--script_path", required=True, type=str, help="The full path of the script"
    )
    oss_parser.add_argument(
        "--script_arguments",
        required=False,
        type=str,
        help="The list of arguments to pass to the script",
    )
    oss_parser.add_argument(
        "--oss_location",
        required=True,
        type=str,
        help="The Object Storage location of the script or a compressed archive containing the script. "
        "The location can be provided as PAR or object URL. If an object URL is provided, the bucket containing "
        "the object must have public read access",
    )
    oss_parser.add_argument(
        "--mode",
        choices=[_DrcsConstants.PRECHECK_MODE, _DrcsConstants.EXECUTE_MODE],
        required=True,
        type=str,
        help="The script executor's mode. 'precheck' mode checks all provided arguments but does not execute the script. 'execute' mode executes the script with"
        "all provided arguments",
    )
    oss_parser.add_argument(
        "--run_as_user",
        required=False,
        type=str,
        help="The user ID to use for executing the script. If not provided, the default OCA user ID (orarun) will be used",
    )
    oss_parser.add_argument(
        "--oss_log_location",
        required=False,
        type=str,
        # help="This option is not currently supported"
        help=argparse.SUPPRESS,
    )

    oss_parser.add_argument(
        "--log_upload_interval",
        required=False,
        type=int,
        default=_DrcsConstants.DEFAULT_LOG_UPLOAD_INTERVAL,
        # help="This option is not currently supported"
        help=argparse.SUPPRESS,
    )

    parser_args, unknown = parser.parse_known_args()

    if unknown:
        parser.print_help()
        log.error("Unknown option specified - [{}]".format(unknown))
        sys.exit(1)

    if len(sys.argv) == 1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    return parser_args


class DRCSScriptExecutor(object):
    """
    DRCSScriptExecutor API that handles the following use case:

    1. Performs the prechecks
        1.1 User input validations
        1.2 Script interpreter exists
        1.3 Script path exists
        1.4 SUDO configuration
        1.5 OSS Script PAR validation
        1.6 OSS log location PAR validation
    2 Execute the script
        2.1 Performs all above validations
        2.2 Starts FSDR Worker that uploads the logs generated by this script to Customer ObjectStore using PAR URL
        2.3 Downloads the scripts from ObjectStore using PAR
        2.4 Extract all supported archive formats
        2.5 Verify the script provided exists in the downloaded object
        2.6 Executes script
        2.7 Executes script using SUDO
        2.8 Upload logs to ObjectStore every few seconds
        2.9 Logs customer scripts output to local logfile and also uploads to ObjectStore
    """

    worker = None

    def __init__(self):
        global log

        prc = subprocess.Popen(_DrcsConstants.DRCS_CMD_EXECUTE_CLEAR)
        prc.communicate()

        args = argumentParser()
        loggerObject = _Logger()
        log = loggerObject.getLogger()
        log.info("Starting DRCSScriptExecutor...")
        signal.signal(signal.SIGINT, _CleanUpOnProcessTerminate().signal_handler)

        self._main(loggerObject.getLogFile(), args)

    def _main(self, logfile, args):
        """
        DRCSScriptExecutor starts here...
        """

        __status = 0

        global stopDrcsWorker

        # args = argumentParser()
        log.info("OCI Full Stack Disaster Recovery Agent For OCA")
        if args.oss_log_location is not None and len(args.oss_log_location) > 0:
            interval = (
                _DrcsConstants.DEFAULT_LOG_UPLOAD_INTERVAL
                if args.log_upload_interval < 10
                else args.log_upload_interval
            )
            self.worker = _DRCSWorker(interval, args.oss_log_location, logfile)
            # Start FSDR Worker that uploads to logfile to ObjectStore
            self.worker.start()

        # Run precheck and fail it if fails
        if _Precheck(args.script_type, args).run():
            __status = 1
            log.error(
                "{} Some of the prechecks are failed. Check the above logs for more details.".format(
                    _DrcsConstants.PRECHECK_TAG
                )
            )

        # Execute operation if Mode is Execute and prechecks was successful
        if __status == 0 and args.mode == _DrcsConstants.EXECUTE_MODE:
            __status = _Execute(args.script_type, args).execute()
        stopDrcsWorker = True

        # Exist with given status code
        self._exit(__status)

    def _exit(self, __status):
        """
        Exit the agent and upload the logs one last time if needed
        """

        if self.worker is not None:
            log.info("FSDR worker is alive, so attempting uploading logs one last time")
            self.worker.upload_logs()
            log.info("Logfile uploaded to OSS one last time")
        else:
            log.info("FSDR worker is not alive")

        if __status > 0:
            log.error("[{}] Script execution was failed".format(__status))
        else:
            log.info("[{}] Script execution was successful".format(__status))

        sys.exit(__status)


if __name__ == "__main__":
    """
    DRCSScriptExecutor starts here
    """

    DRCSScriptExecutor()
